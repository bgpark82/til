
# SKIP_LOCKED

`SKIP_LOCKED`은 트랜잭션이 특정 행을 조회할 때 **해당 행이 락이 걸려 있으면 기다리지 않고 건너뛰고 다음 데이터를 조회**합니다.

## 예시

| id | task_name | status |
| --- | --- | --- |
| 1 | Task A | PENDING |
| 2 | Task B | PENDING |
| 3 | Task C | COMPLETED |

### 1. 여러개의 행이 있는 경우
트랜잭션 A: id=1을 먼저 락 걸음
```sql
BEGIN;
SELECT * FROM task_queue WHERE id = 1 FOR UPDATE;
```
트랜잭션 B: SKIP LOCKED를 사용하여 여러 개의 PENDING 작업 중 하나를 가져옴
```sql
SELECT * FROM task_queue WHERE status = 'PENDING' FOR UPDATE SKIP LOCKED LIMIT 1;
```
- id=1은 락이 걸려 있으므로 SKIP(건너뜀)
- 대신 id=2 또는 id=3 중 하나를 선택하여 반환
- 만약 id=1밖에 없다면 결과는 빈 결과(0 rows)

### 2. 하나의 행만 있는 경우
트랜잭션 A: id=1인 행을 먼저 락을 걸고 처리 중
```sql
BEGIN;
SELECT * FROM task_queue WHERE id = 3 FOR UPDATE;
```

트랜잭션 B: SKIP LOCKED 사용하여 id=3을 조회하려고 시도
```sql
SELECT * FROM task_queue WHERE id = 3 FOR UPDATE SKIP LOCKED;
```
- 결과: 아무것도 반환되지 않음 (0 rows)
- 이유: id=3이 이미 트랜잭션 A에 의해 락이 걸려 있으므로, SKIP LOCKED는 이를 건너뛰고 처리 가능한 행을 찾음 → 하지만 조건을 만족하는 다른 행이 없으므로 빈 결과 반환




## 역사
1. 데드락 해결
  - 전통적인 `FOR UPDATE` 또는 `FOR SHARED` 락 방식은 특정 행에 락을 검
  - 만약, 트랜잭션이 서로의 자원에 접근하려고 하면 데드락이 생김
  - 이때, `SKIP_LOCKED`는 락이 걸린 경우 다음 데이터를 조회하기 때문에 데드락을 방지

> 데드락 해결 방법
> 1. 동일한 순서로 락 획득
> 2. NOWAIT, SKIP_LOCKED
> 3. DBMS의 데드락 감지 기능: 트랜잭션 하나를 강제 ROLLBACK, 예외 처리하고 자동 재시도

2. 높은 동시성 (빠른 처리)
  - 은행, 결제 시스템에서 다수의 프로세스가 동시에 데이터를 가져와 처리하는 경우, 락이 해제될때 까지 기다리는 것은 비효율적
  - 만약 데이터 처리가 길어지면 대기가 길어집니다. 즉, 성능 저하가 발생
  - `SKIP_LOCKED`으로 처리 가능한 데이터만 빨리 가져오게 가능
  - **배치 작업** 혹은 **비동기 작업**을 여러 워커가 동시에 처리할 때 사용

3. **큐**에 적합
  - 배치 작업이나 비동기 작업을 여러 워커에서 동시에 처리
  - 하지만, 처리 순서가 중요한 경우 `NO_WAIT` 또는 트랜잭션 재시도가 적합

> **NO_WAIT과 SKIP_LOCKED 차이**
> - NO_WAIT: 락이 걸린 행을 조회하면, 즉시 예외발생, 대기하지 않음, 예외를 처리해야 함
> - SKIP_LOCKED: 락이 걸린 행을 조회하면, 다른 행을 조회, 일부 데이터 무시 


## 주의사항
1. 공정성(Fairness)/일관성 보장 안됨
  - 순차처리를 보장못하므로 일부 데이터는 영원히 선택안될 수 있습니다. (예약 시스템에서는 비권장)
  - 예를 들어, 한 트랜잭션에서 `ORDER_ID = 1, 2, 3, 4`를 조회해야 하는데, `1, 2`가 이미 락이 걸려 있으면 `3, 4`만 조회됨 → 데이터 유실 가능
2. 락 걸린 행 조회불가
  - 이미 락이 걸린 행은 건너 뛰고, 지속적으로 건너 뛰어 질 수 있습니다.
3. 순차적 처리가 필요한 경우 부적합
  - 예를 들어, FIFO(선입선출) 방식으로 데이터를 처리해야 하는 경우 `SKIP_LOCKED`를 사용하면 순서가 꼬일 수 있음.


## PESSIMISTIC
1. PESSIMISTIC_WRITE
  - 쓰기 락을 걸어 다른 트랜잭션이 **읽거나 수정하지 못하게 함**
  - `FOR UPDATE`(쓰기 락)와 동일
  - 강력한 쓰기 보호

2. PESSIMISTIC_READ
  - 읽기 락을 걸어 다른 트랜잭션이 쓰지 못하지만 읽을 수는 있음 
  - `LOCK IN SHARE MODE`(읽기 락)와 동일
  - 공유 읽기 허용

## PESSIMISTIC_READ
공유락을 명시적으로 설정하여 동시성 해결할 때 사용. 즉, 읽는 동안 다른 사람들로 부터 수정이 안되도록 막을 때 사용
1. 참조 무결성 유지
  - 고객 계좌의 잔액 조회할 때, 계좌가 다른 트랜잭션에 삭제되거나 수정되는 것을 방지
  - 트랜잭션 A: 계좌 id = 1의 잔액 조회
  - 트랜잭션 B: 계좌 id = 1의 계좌를 삭제하려고 한다
  - 트랜잭션 A가 `LOCK IN SHARE MODE`를 사용하면, 트랜잭션 B는 계좌를 삭제하거나 수정할 수 없다. 즉, 읽기만 가능
2. 동시성 제어
  - 동시에 동일한 데이터를 읽을 때 데이터가 수정되는 것을 방지
  - 예약 시스템에서 좌석을 예약할 때, 다른 사람이 같은 좌석을 수정하거나 삭제 못하게 방지
  - 트랜잭션 A: 좌석 id = 1를 조회
  - 트랜잭션 B: 좌석 id = 1의 좌석을 예약 시도
  - 트랜잭션 A가 `LOCK IN SHARE MODE`를 사용하면, 트랜잭션 B는 좌석을 예약, 삭제, 수정 할 수 없다
