# LinkedList vs ArrayDeque

TL;DR

| 비교 항목 | LinkedList | ArrayDeque |
| --- | --- | --- |
| **메모리 사용량** | 높음 (추가 포인터 필요) | 낮음 (배열 기반) |
| **GC 부담** | 높음 (많은 객체 생성) | 낮음 (단일 배열) |
| **캐시 효율** | 낮음 (노드가 흩어짐) | 높음 (연속된 메모리) |
| **연산 속도** | 상대적으로 느림 | 빠름 |

둘 다 Queue의 구현체이다. 하지만 알고리즘에서 선호하는 것은 **ArrayDeque**다.

왜 그런지 알기 위해서는 두 가지가 어떻게 구현되는지 알아야 한다.

### **LinkedList**

LinkedList는 **Doubly LinkedList**이다. 즉, 노드가 양방향으로 연결된 형태이다.

노드라는 객체를 생성하고 prev와 next라는 포인터를 가지고 있으므로 힙 영역에 많은 메모리가 소비된다.

노드를 힙 메모리 여기저기에 생성하므로 캐시 성능도 떨어진다.

마지막으로 여기저기 흩어진 노드를 GC해야 하므로 GC 비용이 추가된다.

### **ArrayDeque**

ArrayDeque는 배열로 구현된다.

그러므로 포인터가 없어 메모리가 덜 사용되고, 힙에 연결된 자료구조로 남아 GC에 부담이 없다.

또한 연속된 데이터 구조는 캐시 사용에 용이하다.

### **연속된 데이터 구조가 캐시에 용이한 이유**

왜냐하면 프로그램은 데이터를 연속적으로 접근하는 경향이 있다.

예를 들어, 반복문을 사용하는 것이 그 예이다.

또한 CPU는 데이터를 메모리에서 가져올 때 일정 크기(64바이트)로 묶어서 가져온다. ([Cache Line](https://stackoverflow.com/questions/3928995/how-do-cache-lines-work))

예를 들어, int(4바이트) 배열(arr)이 있다고 가정해보자.

arr[0]을 가져오려면 4바이트만큼만 가져오는 게 아니라 배열에서 64바이트만큼을 한꺼번에 가져온다.

그래서 ArrayDeque는 캐시 히트율이 높을 가능성이 높다.

그러므로 더 빠른 연산이 가능하다.