# Bitmask

**TL;DR**
> Set의 중복 확인을 비트로 변환하여 처리 가능 
> 공간복잡도: Set O(n) -> 비트마스크 O(1)

비트마스크는 비트 연산을 통해 빠르게 데이터를 처리할 수 있다.

특히, 중복확인을 더 빠르게 할 수 있다
Set으로 중복여부를 확인한다면 bitmask로 **공간복잡도**를 줄여버릴 수 있다

만약 `[1, 2, 5, 7]`이라는 set이 있고, 5가 존재하는지 확인하려면 set을 비트로 바꿔버릴 수 있다
위 set은 `10100011` 비트로 표현가능하다. 각 자리수가 숫자, 1은 존재, 0은 존재하지 않음을 의미한다
```
[10100011]
[7 5   21]
```
만약 존재하는 숫자가 5라면, 5번째 자리에 1이 있는지 확인하면 된다.
5는 비트로 표현하려면 1을 왼쪽으로 5번 밀어버리면 된다
```
1 << 5
```
이 비트는 `00000100000`이다. 이 비트와 원래의 비트를 비교하면 된다
`&` 연산자는 두 비트가 모두 1일 때만 1을 반환한다
```
  [10100011]
& [00100000]
= [00100000]
```
5의 자리에 1이 존재하므로 결과는 1을 반환한다

공간복잡도는 set이면 O(n)이지만, 비트마스크는 비트를 **단일 숫자로 표현**하므로 O(1)이다
이렇게 비트마스크를 사용하면 중복확인을 더 빠르게 할 수 있다

🚨 주의할 점은 절대 10진수로 생각하면 안된다는 점이다
우리는 비트의 각 자리를 숫자로 표현한 것 뿐이다. 10진수로 바꾸면 전혀 의미없는 숫자가 되어 버린다
