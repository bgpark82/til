# Mapper vs DTO

# 도메인 객체 <-> DTO 변환 방식 비교: Mapper vs DTO 내부 변환

스프링 부트(Spring Boot)를 포함한 많은 프레임워크에서 계층 간 데이터 전송을 위해 도메인 객체(Domain Object, Entity)와 DTO(Data Transfer Object)를 사용하며, 이 둘 사이의 변환은 필수적입니다. 변환 방법에는 여러 가지가 있으며, 그중 대표적인 Mapper 사용 방식과 DTO 내부에서 변환하는 방식을 비교 분석해 보겠습니다.

## 1. Mapper 사용 방식 (e.g., MapStruct, ModelMapper, Custom Mapper)
별도의 Mapper 클래스 또는 인터페이스를 정의하여 변환 로직을 담당하게 하는 방식입니다.

### 📌 왜 사용하게 되었는가? (Motivation)
- **관심사의 분리 (Separation of Concerns, SoC)**: 도메인 객체는 핵심 비즈니스 로직과 상태에 집중하고, DTO는 데이터 전송 형식에 집중하며, Mapper는 변환이라는 책임만 담당하여 코드의 응집도를 높입니다.
- **코드 중복 제거 및 재사용성**: 동일한 변환 로직을 한 곳에서 관리하여 재사용이 가능.
- **자동화 및 생산성 향상**: MapStruct 같은 라이브러리는 컴파일 시점에 변환 코드를 생성하여 개발 생산성을 높임.
- **테스트 용이성**: 변환 로직이 별도의 클래스로 분리되어 단위 테스트가 용이함.

### 🏛 언제 등장했는가? / 누가 발명했는가? (History/Origin)
- 단일 책임 원칙(SRP)과 관심사의 분리(SoC)가 강조되면서 자연스럽게 등장한 패턴.
- 계층화 아키텍처가 발전하면서 필요성이 커짐.
- Dozer, ModelMapper, Orika, MapStruct 등 다양한 매핑 라이브러리들이 2000년대 중후반부터 활발히 개발됨.

### ✅ 장점 (Pros)
- 높은 **응집도** 및 **낮은 결합도**.
- 유지보수 용이성 증가.
- 코드 재사용성 증가.
- 자동화 지원 (특히 MapStruct는 보일러플레이트 코드 감소 및 타입 안정성 확보).

### ❌ 단점 (Cons)
- **클래스 수 증가**: 별도 Mapper 클래스를 작성해야 함.
- **초기 설정 및 학습 비용**: 매핑 라이브러리 사용법 익혀야 함.
- **라이브러리 의존성**: 외부 라이브러리를 사용해야 함.
- **디버깅 어려움**: 일부 라이브러리는 생성된 코드를 디버깅해야 할 수 있음.

---

## 2. DTO 내부에서 객체 변경 (e.g., 정적 팩토리 메소드, 생성자, 인스턴스 메소드)
DTO 클래스 내부에 도메인 객체를 인자로 받아 DTO 객체를 생성하는 `from()` 같은 정적 팩토리 메소드나 `toEntity()` 같은 인스턴스 메소드를 두는 방식입니다.

### 📌 왜 사용하게 되었는가? (Motivation)
- **단순성 및 편의성**: 간단한 변환의 경우, 별도의 클래스를 만들지 않고 바로 구현 가능.
- **코드량 감소**: 별도의 Mapper 클래스 없이 변환 가능.
- **관련 로직의 응집**: DTO 관련 로직이 DTO 클래스 내에 위치.

### 🏛 언제 등장했는가? / 누가 발명했는가? (History/Origin)
- 객체 지향 프로그래밍 초기부터 자연스럽게 사용된 방식.
- 복잡도가 낮거나 빠른 프로토타이핑이 필요할 때 선호됨.

### ✅ 장점 (Pros)
- **구현 용이성**: 간단한 변환을 빠르게 구현 가능.
- **클래스 수 감소**.
- **외부 라이브러리 불필요**.
- **직관성 (간단한 경우에 한정)**.

### ❌ 단점 (Cons)
- **단일 책임 원칙(SRP) 위반**: DTO가 변환 책임까지 가짐.
- **결합도 증가**: DTO가 도메인 객체의 내부 구조를 알아야 함.
- **테스트 어려움**: 도메인 객체와의 의존성이 높아 단위 테스트가 복잡해질 수 있음.
- **변환 로직 분산**: 여러 DTO에서 중복될 가능성이 높음.
- **양방향 변환 어려움**: `toEntity()`를 DTO 내부에 두면 도메인 로직이 DTO로 노출될 위험.

---

## 비교 요약

| 항목 | Mapper 사용 방식 (e.g., MapStruct) | DTO 내부 변환 방식 |
|------|--------------------------------|----------------------|
| 핵심 원칙 | 관심사 분리 (SoC), SRP 준수 | 단순성, 편의성 (SRP 위반 가능성) |
| 결합도 | 낮음 (Domain <-> DTO 의존성 최소화) | 높음 (DTO가 Domain에 직접 의존) |
| 응집도 | 높음 (변환 로직은 Mapper에 응집) | 낮음 (DTO가 데이터 + 변환 책임) |
| 코드 재사용성 | 높음 | 낮음 (로직 분산 가능성) |
| 테스트 용이성 | 높음 (Mapper 독립 테스트 가능) | 낮음 (Domain 의존성 필요) |
| 코드량 | 클래스 수 증가, (라이브러리 사용 시) 보일러플레이트 감소 | 클래스 수 적음, 수동 변환 코드 필요 |
| 유지보수성 | 높음 (변경 영향 범위 명확) | 낮음 (변경 시 여러 DTO 수정 가능성) |
| 학습 곡선 | (라이브러리 사용 시) 초기 학습 필요 | 낮음 |
| 적합한 상황 | 복잡한 변환, 재사용 필요, 대규모 프로젝트 | 매우 간단한 변환, 프로토타입, 소규모 프로젝트 |
| 주요 장점 | SoC, 재사용성, 유지보수성, 자동화(라이브러리) | 단순함, 빠른 구현, 클래스 수 적음 |
| 주요 단점 | 클래스 수 증가, 초기 설정/학습 비용 | SRP 위반, 높은 결합도, 낮은 유지보수성 |

---

## 결론 및 권장 사항
- **대규모 프로젝트**에서는 Mapper 사용을 권장합니다. 특히 MapStruct 같은 라이브러리를 활용하면 생산성과 성능, 타입 안정성을 확보할 수 있습니다.
- **DTO 내부 변환 방식**은 단순한 경우에 한정하여 사용해야 합니다. 예를 들어, 1:1 매핑 수준에서 강하게 결합된 경우.
- **장기적인 유지보수성**을 고려하면 Mapper를 사용하여 관심사를 명확히 분리하는 것이 더욱 견고하고 유연한 설계를 만드는 데 도움이 됩니다.

결국 프로젝트의 규모, 복잡성, 유지보수 요구사항 등을 종합적으로 고려하여 적절한 방식을 선택해야 합니다.

