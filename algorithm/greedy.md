# Greedy

💡 탐욕 알고리즘이란?
매 단계마다 "최적"이라고 생각되는 선택을 하는 방식.
한 번 결정한 선택은 바꾸지 않고, 그 선택들이 모여 전체 최적해가 되도록 기대함.

✅ 이 코드에서의 Greedy 포인트
```java
if (i + nums[i] >= goal) {
    goal = i;
}
```
현재 인덱스 i에서 goal까지 도달할 수 있다면,
"굳이 더 멀리 가려고 하지 않고", 그냥 지금 위치 i를 새로운 목표로 바꿔버림.

즉, "goal까지 도달할 수 있기만 하면 그 지점으로 점프해!"
→ "더 멀리 갈 수 있는 다른 곳? 관심 없어. 당장 도달만 하면 돼."
→ 이게 Greedy.

### 🤔 왜 그게 맞는 선택이야?
이 문제는 **도달 가능성(boolean)**만 중요하고,
가장 짧은 경로나 최대 점프 수를 묻는 게 아님.
그러니까 **지금 goal까지 닿을 수 있는가?**라는 조건만 탐욕적으로 만족하면 되는 문제야.

### Greedy가 여기서 잘 통하는 이유는:
문제 구조상 "부분 최적해가 전체 최적해로 이어질 수 있는 상황"이기 때문이야.

🔁 다른 방식(비 Greedy)과 비교
DP 방식이라면, 예를 들어 **각 인덱스에서 도달 가능한 곳을 기억**하고, **모든 경우를 계산**해서 마지막 인덱스까지 도달 가능한지를 본다. 이건 메모리를 더 쓰고, 시간도 더 걸려.

Greedy는 그걸 하지 않고 "**지금 이 순간에서 가능한 최소 조건만 따져서**" 진행해.

✅ 결론
이 알고리즘이 Greedy인 이유는 다음과 같아:

**"지금 당장 goal까지 도달할 수 있다면, 그걸로 충분하다"**는 판단을** 한 번도 되돌리지 않고 끝까지 밀고 나가**서 문제를 푼다.

Q1. 이 문제를 Top-down 방식의 DP로 바꾸면 어떤 구조가 될까?
Q2. 만약 "최소 점프 수"를 구하라고 하면 Greedy로 해결 가능할까?
Q3. 이 방식이 통하지 않는 유사한 문제를 예시로 들어줄 수 있어?

👶 5살에게 설명하자면
"이 게임에서 너는 매번 '나 여기서 저기까지 닿을 수 있어?'만 생각해.
가능하면 바로 '그럼 여기가 내 새 목표야!' 하고 바꿔.
더 좋은 방법이 있을 수도 있지만 넌 '그냥 지금 되는 거만 보면 돼!'라고 말하면서 앞으로 가는 거야.
이게 탐욕(Greedy)이야. 그냥 매번 지금 좋은 걸 고르는 방식이야."

✅ Q1. 이 알고리즘을 앞으로 가면서 푸는 방식으로 바꾼다면 어떻게 될까?
앞으로 가는 Greedy 방식도 있어. 다음과 같은 식으로 구현 가능해:

```java
public boolean canJump(int[] nums) {
    int maxReach = 0;  // 지금까지 갈 수 있는 가장 먼 인덱스

    for (int i = 0; i <= maxReach; i++) {
        maxReach = Math.max(maxReach, i + nums[i]);
        if (maxReach >= nums.length - 1) return true;
    }

    return false;
}
```
## 로직 설명
maxReach는 현재까지 도달할 수 있는 최대 인덱스.

현재 인덱스 i가 maxReach를 넘어서면 더 이상 진행 불가 → false.

계속 maxReach를 업데이트하며 마지막 인덱스 이상까지 갈 수 있으면 true.

### 기존 방식과의 차이
기존 방식은 뒤에서 앞으로 가능한 지점을 좁혀가고,

이 방식은 앞에서부터 최대 도달 가능한 인덱스를 넓혀간다.

둘 다 Greedy지만, 방향이 다를 뿐 핵심 아이디어는 동일.

✅ Q2. Greedy가 항상 통하는 문제와 통하지 않는 문제는 어떤 차이가 있을까?
✅ Greedy가 항상 통하는 문제
**"부분 최적해가 전체 최적해로 이어지는 경우"**만.

이걸 Greedy Choice Property라고 불러.

예시
Jump Game (이 문제) – 도달 가능 여부만 중요

활동 선택 문제(Activity Selection) – 가장 빨리 끝나는 걸 먼저 고르면 전체 최댓값

Fractional Knapsack – 물건을 쪼갤 수 있는 경우, 무게당 가치 높은 순으로 담으면 끝

### ❌ Greedy가 통하지 않는 문제
**중간에 잘못된 선택**을 했을 때 **되돌려야만 최적해를 얻을 수 있는 문제**.

즉, 과거의 선택을 바꿔야 하는 경우에는 Greedy가 실패함.

예시
0-1 Knapsack – 쪼갤 수 없으므로 Greedy로는 최적 선택이 안 됨
최단 경로 문제 – Dijkstra는 가중치가 음수면 Greedy가 안 통함
Job Scheduling with Deadlines – 여러 조건이 복합적으로 얽힐 경우 DP 필요

### ✅ Q3. 이 알고리즘에서 최악의 경우란 어떤 케이스일까?
최악의 경우는 다음과 같은 조건이야:

배열 전체를 끝까지 순회해야 하는 경우

예: [1,1,1,1,1,1,1,...,1] 같은 경우 (계속 한 칸씩만 전진 가능)

🔍 시간 복잡도 측면에서 보면
어차피 O(n)이지만, early return이 안 되고 끝까지 다 봐야 해서 최악이 됨.

### 🧠 정리
앞으로 가는 방식	최대 도달 가능한 범위를 업데이트하면서 진행
Greedy가 통하는 조건	부분 최적해 → 전체 최적해 (Greedy Choice Property)
최악 케이스	모든 칸을 방문해야만 하는 경우 (점프 길이 1씩)
